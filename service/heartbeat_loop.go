package main

import (
    "time"
    "github.com/arschles/eiger/lib/util"
)

type HeartbeatLoop struct {
    lookup *AgentLookup
    hbDur time.Duration
    notifyCh chan *Agent
}

func NewHeartbeatLoop(lookup *AgentLookup, hbDur time.Duration) *HeartbeatLoop {
    notifyCh := make(chan *Agent)
    loop := HeartbeatLoop{lookup, hbDur, notifyCh}
    go loop.run()
    return &loop
}

//Notify tells the internal heartbeat loop that an agent has heartbeated.
//on the first heartbeat, tells the internal heartbeat loop that the agent
//exists and prompts it to start watching that agent.
func (h *HeartbeatLoop) Notify(a *Agent) {
    h.notifyCh <- a
}

//agentWatcher watches a single agent for ticks generated by notifyLoop.
//run in a goroutine per agent, generated by notifyLoop
func (h *HeartbeatLoop) agentWatcher(agent *Agent, ticker <-chan bool) {
  for {
      start := time.Now()
      select {
      case <-ticker:
          if time.Since(start) > h.hbDur * 4 {
              util.LogWarnf("(late heartbeat) removing agent %s from alive set", *agent)
              h.lookup.Remove(agent)
              return
          }
      case <-time.After(h.hbDur * 2):
          util.LogWarnf("(heartbeat timeout) removing agent %s from alive set", agent)
          return
      }
  }
}

//run is the core loop to watch over all agents. run in a goroutine
func (h *HeartbeatLoop) run() {
    tickers := map[*Agent]chan bool{}
    for {
        agent := <-h.notifyCh
        ticker, ok := tickers[agent]
        if !ok {
            ticker := make(chan bool)
            tickers[agent] = ticker
            go h.agentWatcher(agent, ticker)
        }
        go func() {
            ticker <- true
        }()
    }
}
